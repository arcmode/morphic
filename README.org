#+TITLE: The frameless pattern: Modularity as a platform
#+AUTHOR: David Rojas
#+EMAIL: (concat "drojascamaggi" at-sign "gmail.com")

#+OPTIONS: toc:nil num:2 H:3 ^:nil pri:t title:nil
#+EXPORT_FILE_NAME: index
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://drojas.github.io/org-html-dracula/styles/org.css">
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="styles/org.css">

#+BEGIN_export html
<h1 class="title">
  <span class="accent">></span> add module --type res<span class="inverse">t</span>
</h2>
#+END_export

#+BEGIN_abstract
Boilerplate code is an underrated problem: the chunks of non-reusable code and other necessary evils that are usually
granted as scaffolding or abstracted away as a mixture of library code and configuration are cheap to buy but come as very
expensive to replace. There is accidental complexity in most if not all boilerplate code around any /main/ function or any module
that depends on a library or framework. Therefore, when working with multiple /main/ functions (specially microservices, or
distributed systems) and multiple modules this space for boilerplate can allow some problems that then scale with the number of
/mains/ at play and the total number of modules including code repetition and long cycle times. This document proposes a
"frameless" design pattern for building modular systems without boilerplate code and allow modules to be developed without having
any source-code dependency on the framework/library API and facilitates the co-evolution of business domain features and platform
features in alignment with the dynamics of the agile methodologies
#+END_abstract

#+TOC: headlines 2

* TL;DR;

Instead of doing:

1) Select framework and libraries
2) Write some boilerplate code
3) Implement a set of modules following the modularity model from framework

Try the "frameless" pattern:

1) Define modularity model via a /platform/ function: ~platform : modules -> features~
2) Implement the platform function as a thin wrapper that can include a module as part of predefined boilerplate
3) Define boilerplate according to /your/ platform
4) Implement set of modules following /your/ modularity model

* Modularity: A tale about separation of concerns

Most projects grow in a modular pace, adding new features incrementally to do the work that is required.
Also, most projects work on top of a given platform, /composed/ by the set of languages, frameworks and libraries that together provide at least
one and sometimes several modularity models from which most projects pick one for each kind of module (job, route, library, DOM component, cli, etc).
During development of new features, the difference between the modularity model offered by the platform and that of the type of project
increases the size of the task at hand every /sprint/ by forcing part of the solution to be dedicated to the interface between the two models.

* Problem
** Modularity vs Evolvability
In modular software, the work required to /migrate/ a given module into a different /framework/ should be considered evitable and patterns that add
work to that could be considered anti-patterns. Note: the previous claim is explicitly refering to changes to module code,
not project boilerplate code or library code.

** Modularity vs consistency
Most web projects require significant boilerplate code in order to run production applications. One of the most obvios properties 
of modular systems is the bigger number of running programs. The combination of modularity with patterns and tools that increase
boilerplate code creates a space for inconsistency that affects modular systems as they adopt new features and behavior not
yet defined within the "boilerplate-free" area of library and framework code.

# ** Modularity vs cycle time

* Solution
*** Modularity Model
   The module/framework relationship is modeled as inspired by the organism/niche relationship. One aspect of that relationship that can be
   recognized is the apparent level of adaptation. An adapted organism can benefit from the ecosystem and thrive by means of a multi-dimensional
   interface composed by sensorial organs, motor systems and other biological structures.\\
   Hypothesis: A systemic modularity model will help improve source code consistency and reduce overall complexity
   
   Let's imagine for example a common kind of project for "web" projects: Rest API in NodeJS.

   Before working on boilerplate code yet, let's define our /Rest module/ model in TypeScript trying to achieve the /minimum viable interface/
   required to know what the module /does/ in the context of the specific project (Rest API).

#+BEGIN_SRC typescript
  export const url = '/hello-rest/:name'
  export const method = 'GET'

  type Request = {
      params: {
          name: string
      }
  }

  type Result = {
      status: 200,
      headers: {
          ['powered-by']: 'your-platform'
      },
      body: {
          greetings: string
      }
  } | {
      status: 500,
      body: {
          errors: string[]
      }
  }

  export const schema = {
      response: {
          200: {
              type: 'object',
              properties: {
                  greetings: {
                      type: 'string'
                  }
              }
          },
          500: {
              type: 'object',
              properties: {
                  errors: {
                      type: 'array',
                      items: {
                          type: 'string'
                      }
                  }
              }
          }
      }
  }

  export const handler = async (req: Request): Promise<Result> => {
      try {
          return {
              status: 200,
              headers: {
                  ['powered-by']: 'your-platform'
              },
              body: {
                  greetings: `Hello ${name}`
              }
          }
      } catch (err) {
          return {
              status: 500,
              body: {
                  errors: [err.message]
              }
          }
      }
  }
#+END_SRC

   Then, the /minimum viable interface/ of a Rest Module can be defined as
#+BEGIN_SRC typescript
  type RestMod<
      Query,
      Params,
      Headers,
      Body,
      Config,
      Result,
      > = {
          url: string,
          method: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE',
          schema: RouteSchema<object>,
          config?: Record<keyof Config, string | undefined>,
          handler: (req: RestRequest<Query, Params, Headers, Body>, cfg: Config) => Promise<Result>
      };
#+END_SRC

   Now let's solve the boilerplate from the requirements we know given the module type definition
 #+BEGIN_SRC typescript
   import fastify from 'fastify';
   import { createFastifyPlugin } from '@morphic/rest';
   import config from 'config';
   //
   // import rest modules
   //
   import * as morphicExamplesHelloRest from '@morphic-examples/hello-rest';

   const instance = fastify({
       logger: true
   });

   //
   // add base plugins for initialization
   //

   //
   // add rest modules to the service
   //
   instance.register(createFastifyPlugin(morphicExamplesHelloRest, config));

   const PORT = config.has('PORT')
       ? parseInt(config.get('PORT'), 10)
       : 0;

   instance.listen(PORT, (err: Error, address: string) => {
       if (err) {
           throw err;
       }
       instance.log.info(`server listening on ${address}`);
   });

#+END_SRC

*** TODO Contracts: The network defines the ecosystem
   The difference between an ecosystem and the niche is the emphasis about the specific "role" an organism plays as part of the ecosystem and the
   specific "experience" the organism has in said ecosystem. Without twisting biology too much math into biology one could say the niche of an
   organism is the experience it has within the ecosystems it is embedded in plus the difference it produces in the experience of the other systems.\\
   # Hypothesis: A systemic modularity model will improve the domain language by allowing the exercise of a more domain-focused interfaces
*** TODO Robustness
   Hypothesis: A formal modularity model implemented as described above increases quality over time (less bugs)
*** TODO Adaptability
   Hypothesis: A systemic modularity model will improve engineering cycle speed and/or results
*** TODO Extensibility & Evolvability
   Diversity is a key aspect of successful (biological) ecosystems and commonly associated to adaptation.\\
   Hypothesis: A systemic modularity model will increase contributions to its own design and library/framework code
*** TODO Simplicity
   An apparent property of evolution is the reuse of solutions. The evolution of an organism (basically a lineage of
   cells) can be easily compared to the common idea of evolution of species and also to the development of eusocial colonies of insects.\\
   Hypothesis: A systemic modularity model will reduce complexity
*** TODO Agile
   Following, a couple of tech-oriented definitions for modulerity from: https://en.wikipedia.org/wiki/Modularity
#+BEGIN_QUOTE
In modular programming, modularity refers to the compartmentalization and interrelation of the parts of a software package.\\

In software design, modularity refers to a logical partitioning of the "software design" that allows complex software to be manageable
for the purpose of implementation and maintenance. The logic of partitioning may be based on related functions, implementation
considerations, data links, or other criteria.
#+END_QUOTE

   One interesting aspect of the last definition is the idea the relationship between complexity and software being manageable is
   and worth paying close attention to and perhaps explore with "biomimicry lenses".

   Let's compare the previous definitions with a biological one from: https://en.wikipedia.org/wiki/Modularity_(biology)
#+BEGIN_QUOTE
Modularity refers to the ability of a system to organize discrete, individual units that can overall increase the efficiency of network
activity and, in a biological sense, facilitates selective forces upon the network. Modularity is observed in all model systems, and can
be studied at nearly every scale of biological organization, from molecular interactions all the way up to the whole organism.
#+END_QUOTE

   The ideas behind "to be manageable" from the tech-oriented definition and of "selective forces" from the biological one seem aligned with
   the "shortest path" mentality of both nature and the agile movement within the tech industry.

   Modular development pairs naturally with paced or sprint based methodologies.\\
   Hypothesis: A systemic modularity model will reduce uncertainty and support the pace of agile methodologies.

** MVP: Basic module systems
   :PROPERTIES:
   :ID:       38b345b1-681b-4528-8b88-d73980e383e6
   :END:
***** DONE RPC
      CLOSED: [2019-11-17 Sun 19:47]
****** DONE hygen rpc-mod new --in examples --name hello-rpc
       CLOSED: [2019-11-17 Sun 19:43]
****** DONE hygen rpc-api new --in examples --name rpc-simple
       CLOSED: [2019-11-17 Sun 19:43]
***** DONE REST
      CLOSED: [2019-11-17 Sun 19:47]
****** DONE hygen rest-mod new --in examples --name hello-rest
       CLOSED: [2019-11-17 Sun 19:43]
****** DONE hygen rest-api new --in examples --name rest-simple
       CLOSED: [2019-11-17 Sun 19:43]
***** TODO Job
***** TODO Cronjob
***** TODO Worker (Queue consumer)
***** TODO Events producer
***** TODO Events consumer
***** TODO Database app example (MongoDB)
***** TODO K8s codegen
***** TODO Instrumentation

** Vision for v1.0
   More systems and module models
***** TODO Client codegen
***** TODO Frontend components
***** TODO ETL processes
***** TODO Stream processing
***** TODO Vendor modules
***** TODO Platform extensions (Idea: module functors)
***** TODO Service Registry

** Ideas
   :PROPERTIES:
   :ID:       9b25d4a9-a4d2-4ded-9ba1-38420c98c359
   :END:
***** HATEOAS
      :PROPERTIES:
      :ID:       8b9229ef-d571-4a95-bc36-2349f1d988d0
      :END:
***** GraphQL
      :PROPERTIES:
      :ID:       a9a15666-e24e-4918-9a29-f6fa1437096c
      :END:
***** Auto partitioning
***** Bring your own framework example
***** NPM Tarball Functor as a Service

* Inspired partially by
- [[https://evolution.berkeley.edu/evolibrary/article/evodevo_01][Evo-devo]]
- [[https://en.wikipedia.org/wiki/Fractal][Fractals]]
- [[https://github.com/GoogleContainerTools/jib][Jib]]

* Technologies used in this experiment
- [[https://nodejs.org/en/][nodejs]]
- [[https://lerna.js.org/][Lerna]]
- [[https://www.typescriptlang.org/][TypeScript]]
- [[https://www.fastify.io/][fastify]]
- [[https://www.hygen.io/][Hygen]]
 
